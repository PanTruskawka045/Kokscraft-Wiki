name: Verify Markdown Images

on:
  pull_request:
    types: [opened, synchronize, reopened]

jobs:
  verify-images:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.x'

      - name: Run Image Verification Script
        shell: python
        run: |
          import os
          import re
          import sys

          # Flaga b≈Çedu
          has_error = False

          # Regex szukajƒÖcy obrazk√≥w: ![alt](url)
          # WyciƒÖgamy zawarto≈õƒá nawias√≥w okrƒÖg≈Çych
          image_pattern = re.compile(r'!\[.*?\]\((.*?)\)')

          print("üîç Rozpoczynam sprawdzanie poprawno≈õci ≈õcie≈ºek do obrazk√≥w w plikach .md...")

          for root, dirs, files in os.walk('.'):
              # Pomijamy folder .git i node_modules dla wydajno≈õci
              if '.git' in dirs: dirs.remove('.git')
              if 'node_modules' in dirs: dirs.remove('node_modules')

              for file in files:
                  if file.endswith('.md'):
                      file_path = os.path.join(root, file)
                      # Relatywna ≈õcie≈ºka do wy≈õwietlania w logach
                      rel_path = os.path.relpath(file_path, '.')
          
                      try:
                          with open(file_path, 'r', encoding='utf-8') as f:
                              lines = f.readlines()
                      except UnicodeDecodeError:
                          print(f"::warning file={rel_path}::Nie mo≈ºna odczytaƒá pliku (problem z kodowaniem).")
                          continue

                      for i, line in enumerate(lines, start=1):
                          # Znajd≈∫ wszystkie obrazki w danej linii
                          matches = image_pattern.finditer(line)
          
                          for match in matches:
                              # Pobieramy to co jest w nawiasach okrƒÖg≈Çych (≈õcie≈ºka + opcjonalny tytu≈Ç)
                              full_ref = match.group(1).strip()
          
                              # Ignorujemy zewnƒôtrzne linki (http/https)
                              if full_ref.startswith('http://') or full_ref.startswith('https://'):
                                  continue
          
                              # Obs≈Çuga formatu z tytu≈Çem np: /sciezka/img.png "Tytu≈Ç"
                              # Bierzemy tylko pierwszƒÖ czƒô≈õƒá przed spacjƒÖ
                              image_path = full_ref.split()[0]
          
                              # 1. Sprawdzenie czy zaczyna siƒô od "/"
                              if not image_path.startswith('/'):
                                  print(f"::error file={rel_path},line={i}::B≈ÇƒÖd ≈õcie≈ºki: Obrazek '{image_path}' nie zaczyna siƒô od '/'. ≈öcie≈ºki muszƒÖ byƒá absolutne wzglƒôdem roota (np. /assets/img.png).")
                                  has_error = True
                                  continue # Nie sprawdzamy istnienia, je≈õli format jest z≈Çy

                              # 2. Sprawdzenie czy plik istnieje
                              # Usuwamy pierwszy slash, aby po≈ÇƒÖczyƒá ze ≈õcie≈ºkƒÖ systemowƒÖ (root repozytorium to kropka)
                              local_path = image_path.lstrip('/')
          
                              if not os.path.isfile(local_path):
                                  print(f"::error file={rel_path},line={i}::Brak pliku: Plik '{image_path}' nie istnieje w repozytorium.")
                                  has_error = True

          if has_error:
              print("‚ùå Znaleziono b≈Çƒôdy w ≈õcie≈ºkach do obrazk√≥w.")
              sys.exit(1)
          else:
              print("‚úÖ Wszystkie obrazki zweryfikowane pomy≈õlnie.")